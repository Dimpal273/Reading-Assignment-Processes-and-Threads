# Reading-Assignment-Processes-and-Threads
1) Students working at individual PCs in a computer laboratory send their files to be printed by a server that spools the files on its hard disk. Under what conditions may a deadlock occur if the disk space for the print spool is limited? How may the deadlock be avoided?
    Disk space on the spooling partition is a finite resource. Every block that comes in de facto claims a resource and every new one arriving wants more resources. If the spooling space is, say, 10 MB and the first half of ten 2-MB jobs arrive, the disk will be full and no more blocks can be stored so we have a deadlock. The deadlock can be avoided by allowing a job to start printing before it is fully spooled and reserving the space thus released for the rest of that job. In this way, one job will actually print to completion, then the next one can do the same thing. If jobs cannot start printing until they are fully spooled, deadlock is possible.

2) In the preceding question, which resources are preemptable and which are nonpreemptable?
    The printer is nonpreemptable; the system cannot start printing another job until the previous one is complete. The spool disk is preemptable; you can delete an incomplete file that is growing too large and have the user send it later, assuming the protocol allows that.

3) The four conditions (mutual exclusion, hold and wait, no preemption and circular wait) are necessary for a resource deadlock to occur. Give an example to show that these conditions are not sufficient for a resource deadlock to occur. When are these conditions sufficient for a resource deadlock to occur?
    A deadlock is a situation where two or more processes request for same critical resource at the same time.The mutual exclusion applies a restriction to a resource when the resource is used by any process, it should become unavailable for the other resources.The hold and wait allocations explains that any process which is allocate resources must hold them; till all needed resources are nor sure.In the meantime, if any other processes need a resource which is held by another process, then the latter will release the resource to prevent deadlock.No pre-emption states that the operating system can grant access to resources to another process while it is in use by another process; depending on the priority , to prevent deadlock.Circular wait should not be implemented so that resources being requested by process are allocated when they get free.Three processes A, B, and C functions on a system, having two distinct resources R and S.The resource  R has one instant active while resource S has two instances available.The instance of R is allocated to a process A after request. first instance of resource S is allocated to process B, and second instance of resource S is allocated to process C. When a request is placed by process B for resource R, then the resource is not available for execution. the process A request for resource S which is used by both C and B. All the four conditions prevail in this situation; yet deadlock does not occur. The resource S is released by process C and is allocated to process A. when process A finishes, it releases resources and resources R is allocate d to process B. Hence all three processes end without a deadlock. However, the deadlock will prevail for process A, B, and C when two resources R and S; if only one instance of each resources is allowed.

4) Suppose four cars each approach an intersection from four different directions simultaneously. Each corner of the intersection has a stop sign. Assume that traffic regulations require that when two cars approach adjacent stop signs at the same time, the car on the left must yield to the car on the right. Thus, as four cars each drive up to their individual stop signs, each waits (indefinitely) for the car on the left to proceed. Is this anomaly a communication deadlock? Is it a resource deadlock?
    Neither communication or resource deadlock. This anomaly is one of competition synchronization, however, in which cars are waiting for resources in a circular chain and traffic throttling may be an effective strategy for control. To distinguish from resource deadlock, this anomaly might be termed a ''scheduling deadlock.'' A similar deadlock could occur following a law that required two trains merging onto a shared railroad track to wait for the other to proceed. Note that a policeman signaling one of the competing cars or trains to proceed (and not the others) can break this dead state without rollback or any other overhead.

5) A system has two processes and three identical resources. Each process needs a maximum of two resources. Is deadlock possible? Explain your answer.
    The system is deadlock free. Suppose that each process has one resource.There is one resource free. Either process can ask for it and get it, in whichcase it can finish and release both resources. Consequently, deadlock is impossible.

6) The banker's algorithm is being run in a system with m resource classes and n processes. In the limit of large m and n, the number of operations that must be performed to check a state for safety is proportional to m^{a}*n^{b}. What are the values of a and b?
    Comparing a row in the matrix to the vector of available resources takes m operations.This step must be repeated on the order of n times to find a processthat can finish and be marked as done. Thus, marking a process as done takes on the order of mn steps. Repeating the algorithm for all n processes means that the number of steps is then mn2.Thus, a = 1 and b = 2

7) A distributed system using mailboxes has two IPC primitives, send and receive. The latter primitive specifies a process to receive from and blocks if no message from that process is available, even though messages may be waiting from other processes. There are no shared resources, but processes need to communicate frequently about other matters. Is deadlock possible? Discuss.
    Yes. Suppose that all the mailboxes are empty. Now A sends to B and waits for a reply, B sends to C and waits for a reply, and C sends to A and waits for a reply. All the conditions for a communications deadlock are now fulfilled.

8) One way to prevent deadlocks is to eliminate the hold-and-wait condition. In the textbook it was proposed that before asking for a new resource, a process must first release whatever resources it already holds (assuming that is possible). However, doing so introduces the danger that it may get the new resource but lose some of the existing ones to competing processes. Propose an improvement to this scheme.
    Change the semantics of requesting a new resource as follows. If a process asks for a new resource and it is available, it gets the resource and keeps what it already has. If the new resource is not available, all existing resources are released. With this scenario, deadlock is impossible and there is no danger that the new resource is acquired but existing ones lost. Of course, the process only works if releasing a resource is possible (you can release a scanner between pages or a CD recorder between CDs)
